import { Hono } from "hono";
import { initializeLucia, type Env } from "../lib/lucia"; // Import Env
import { hash } from "argon2";
// Explicit Lucia import removed to rely on module augmentation for correct type inference.

const authApp = new Hono<{ Bindings: Env }>(); // Add Bindings type to Hono

authApp.post("/register", async (c) => {
	const body = await c.req.json().catch(() => ({}));

	const { username, password } = body;

	if (!username || typeof username !== "string" || username.length < 3) {
		// Basic validation
		return c.json(
			{ error: "Username is required and must be at least 3 characters" },
			400
		);
	}
	if (!password || typeof password !== "string" || password.length < 6) {
		// Basic validation
		return c.json(
			{ error: "Password is required and must be at least 6 characters" },
			400
		);
	}

	try {
		const lucia: ReturnType<typeof initializeLucia> = initializeLucia(c.env); // Explicitly use the return type
		const hashedPassword = await hash(password);

		const user = await lucia.createUser({
			// In a real scenario, userId might be generated by the adapter or DB
			// For now, we let Lucia handle it or expect the mock to provide it.
			// userId: crypto.randomUUID(), // Example if we needed to generate it here
			attributes: {
				// Lucia expects attributes matching DatabaseUserAttributes (excluding id)
				username,
				// other attributes if any, e.g., email, name
			},
		});

		await lucia.createKey({
			userId: user.userId, // Use userId from the created user
			providerId: "username", // "username" for username/password auth
			providerUserId: username.toLowerCase(), // Lucia typically expects this to be unique
			hashed_password: hashedPassword,
		});

		// Session creation would typically happen on login, not register,
		// but if immediate login after register is desired:
		// const session = await lucia.createSession({ userId: user.userId, attributes: {} });
		// const sessionCookie = lucia.createSessionCookie(session);
		// c.header("Set-Cookie", sessionCookie.serialize());

		return c.json(
			{ message: "User registered successfully", userId: user.userId },
			201
		);
	} catch (e: any) {
		// This is a generic error handler.
		// In a real app, you'd want to check specific error codes/types.
		// For example, Lucia might throw an error with a specific code for duplicate usernames/keys.
		// The test mock for createUser simulates this with LUCIA_KEY_ID_CONFLICT.
		if (
			e.code === "LUCIA_KEY_ID_CONFLICT" ||
			(e.message && e.message.toLowerCase().includes("unique constraint")) ||
			e.message.toLowerCase().includes("username already exists")
		) {
			return c.json({ error: "Username already exists" }, 409);
		}
		// Log the error for debugging purposes
		console.error("Registration error:", e);
		return c.json({ error: "Failed to register user" }, 500);
	}
});

// Define routes like /login, /logout, /me
// Example:

// authApp.post('/login', (c) => {
//   // ... login logic
//   return c.json({ message: 'Logged in successfully' });
// });

// authApp.post('/logout', (c) => {
//   // ... logout logic
//   return c.json({ message: 'Logged out successfully' });
// });

// authApp.get('/me', (c) => {
//   // ... get current user logic (needs auth middleware)
//   // const user = c.get('user'); // Assuming middleware sets this
//   // if (!user) return c.json({ error: 'Unauthorized' }, 401);
//   // return c.json(user);
//   return c.json({ placeholder: "user data" });
// });

export const configureAuthRoutes = () => {
	return authApp;
};
